#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure.

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/

vector<int> bottomView(BinaryTreeNode<int> * root){

    vector<int> ans;
    if (root == NULL)

    {

        return ans;

    }

 

    // Using a map to store nodes at each horizontal distance and level

    map<int, map<int, vector<int>>> nodes;

 

    // Queue to perform level order traversal

    queue<pair<BinaryTreeNode<int> *, pair<int, int>>> q;

 

    // Pushing root node with horizontal distance 0 and level 0

    q.push(make_pair(root, make_pair(0, 0)));

 

    while (!q.empty())

    {

        pair<BinaryTreeNode<int> *, pair<int, int>> temp = q.front();

        q.pop();

 

        BinaryTreeNode<int> * frontNode = temp.first;

        int hd = temp.second.first;

        int lvl = temp.second.second;

 

        // Storing the node's value at its corresponding horizontal distance and level

        nodes[hd][lvl].push_back(frontNode->data);

 

        // Enqueue left child with updated horizontal distance and level

        if (frontNode->left)

        {

            q.push(make_pair(frontNode->left, make_pair(hd - 1, lvl + 1)));

        }

 

        // Enqueue right child with updated horizontal distance and level

        if (frontNode->right)

        {

            q.push(make_pair(frontNode->right, make_pair(hd + 1, lvl + 1)));

        }

    }

 

    // Traverse the nodes map to retrieve the values in vertical order

    for (auto i : nodes)

    {
        int f;
        for (auto j : i.second)

        {

            for (auto k : j.second)
            {
                f=k;
            }
        }
        ans.push_back(f);
    }
    // Return the vertical order traversal of the tree
    return ans;
    
}
